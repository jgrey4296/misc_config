.\" Automatically generated by Pandoc 2.12
.\"
.TH "" "" "" "" ""
.hy
.SH CLIPS 6.30
.SH COMMANDS
.PP
This section gives a general overview of the available CLIPS constructs.
.PP
Subtopics:
.PD 0
.P
.PD
\ \ \ DEFRULE DEFCLASS
.PD 0
.P
.PD
\ \ \ DEFFACTS DEFINSTANCES
.PD 0
.P
.PD
\ \ \ DEFTEMPLATE DEFMESSAGE-HANDLER
.PD 0
.P
.PD
\ \ \ DEFGLOBAL DEFMODULE
.PD 0
.P
.PD
\ \ \ DEFFUNCTION CONSTRAINT_ATTRIBUTES
.PD 0
.P
.PD
\ \ \ DEFGENERIC/DEFMETHOD
.SS DEFRULE
.PP
One of the primary methods of representing knowledge in CLIPS is a rule.
A rule is a collection of conditions and the actions to be taken if the
conditions are met.
The developer of an expert system defines the rules which describe how
to solve a problem.
Rules execute (or fire) based on the existence or non-existence of
facts.
CLIPS provides the mechanism (the inference engine) which attempts to
match the rules to the current state of the system (as represented by
the fact-list) and applies the actions.
.IP
.nf
\f[C]
(defrule <rule-name> [<comment>]
    [<declaration>]
    <conditional-element>*
    =>
    <action>*)
\f[R]
.fi
.SS DECLARATIONS
.IP
.nf
\f[C]
<declaration>           ::= (declare <rule-property>+)

<rule-property>         ::= (salience <integer-expression>) |
                            (auto-focus <boolean-symbol>)
\f[R]
.fi
.SS CONDITIONAL ELEMENTS
.IP
.nf
\f[C]
<conditional-element>   ::= <pattern-CE> | <assigned-pattern-CE> |
                            <not-CE> | <and-CE> | <or-CE> |
                            <logical-CE> | <test-CE> |
                            <exists-CE> | <forall-CE>

<test-CE>               ::= (test <function-call>)

<not-CE>                ::= (not <conditional-element>)

<and-CE>                ::= (and <conditional-element>+)

<or-CE>                 ::= (or <conditional-element>+)

<exists-CE>             ::= (exists <conditional-element>+)

<forall-CE>             ::= (forall <conditional-element>
                                    <conditional-element>+)

<logical-CE>            ::= (logical <conditional-element>+)
\f[R]
.fi
.SS PATTERN CONDITIONAL ELEMENT
.IP
.nf
\f[C]
<assigned-pattern-CE>   ::= ?<variable-symbol> <- <pattern-CE>

<pattern-CE>            ::= <ordered-pattern-CE> |
                            <template-pattern-CE> |
                            <object-pattern-CE>

<ordered-pattern-CE>    ::= (<symbol> <constraint>*)

<template-pattern-CE>   ::= (<deftemplate-name <LHS-slot>*)

<object-pattern-CE>     ::= (object <attribute-constraint>*)

<attribute-constraint>  ::= (is-a <constraint>) |
                            (name <constraint>) |
                            (<slot-name> <constraint>*)

<LHS-slot>              ::= <single-field-LHS-slot> |
                            <multifield-LHS-slot>

<LHS-slot>              ::= <single-field-LHS-slot> |
                            <multifield-LHS-slot>

<single-field-LHS-slot> ::= (<slot-name> <constraint>)

<multifield-LHS-slot>   ::= (<slot-name> <constraint>*)
\f[R]
.fi
.SS PATTERN CONSTRAINTS
.IP
.nf
\f[C]
<constraint>            ::= ? | $? | <connected-constraint>

<connected-constraint>
                ::= <single-constraint> |
                    <single-constraint> & <connected-constraint> |
                    <single-constraint> | <connected-constraint>

<single-constraint>     ::= <term> | \[ti]<term>

<term>                  ::= <constant> |
                            <single-field-variable> |
                            <multifield-variable> |
                            :<function-call> |
                            =<function-call>
\f[R]
.fi
.SS DEFFACTS
.PP
With the deffacts construct, a list of facts can be defined which are
automatically asserted whenever the reset command is performed.
Facts asserted through deffacts may be retracted or pattern matched like
any other fact.
The initial fact-list, including any defined deffacts, is always
reconstructed after a reset command.
.PP
The syntax of the deffacts construct is:
.IP
.nf
\f[C]
(deffacts <deffacts-name> [<comment>]
   <RHS-pattern>*)
\f[R]
.fi
.SS DEFTEMPLATE
.PP
Ordered facts encode information positionally.
To access that information, a user must know not only what data is
stored in a fact but which field contains the data.
Non-ordered (or deftemplate) facts provide the user with the ability to
abstract the structure of a fact by assigning names to each field found
within the fact.
The deftemplate construct is used to create a template which can then be
used by non-ordered facts to access fields of the fact by name.
The deftemplate construct is analogous to a record or structure
definition in programming languages such as Pascal and C.
.PP
The syntax of the deftemplate construct is:
.IP
.nf
\f[C]
(deftemplate <deftemplate-name> [<comment>]
   <slot-definition>*)

<slot-definition>         ::= <single-slot-definition> |
                              <multislot-definition>

<single-slot-definition>  ::= (slot <slot-name>
                                    <template-attribute>*)

<multislot-definition>    ::= (multislot <slot-name>
                                         <template-attribute>*)

<template-attribute>      ::= <default-attribute> |
                              <constraint-attribute>

<default-attribute>
                   ::= (default ?DERIVE | ?NONE | <expression>*) |
                       (default-dynamic <expression>*)
\f[R]
.fi
.SS DEFGLOBAL
.PP
With the defglobal construct, global variables can be defined, set, and
accessed within the CLIPS environment.
Global variables can be accessed as part of the pattern matching
process, but changing them does not invoke the pattern matching process.
The bind function is used to set the value of global variables.
.PP
The syntax of the defglobal construct is:
.IP
.nf
\f[C]
<defglobal-construct> ::= (defglobal [<defmodule-name>]
                             <global-assignment>*)

<global-assignment>   ::= <global-variable> = <expression>

<global-variable>     ::= ?*<symbol>*
\f[R]
.fi
.SS DEFFUNCTION
.PP
With the deffunction construct, new functions may be defined directly in
CLIPS.
Deffunctions are equivalent in use to other functions in CLIPS.
The only differences between user-defined external functions and
deffunctions are that deffunctions are written in CLIPS and executed by
CLIPS interpretively and user-defined external functions are written in
an external language, such as C, and executed by CLIPS directly.
Also, deffunctions allow the addition of new functions without having to
recompile and relink CLIPS.
.PP
The syntax of the deffunction construct is:
.IP
.nf
\f[C]
(deffunction <name> [<comment>]
    (<regular-parameter>* [<wildcard-parameter>])
    <action>*)

<regular-parameter>  ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>
\f[R]
.fi
.SS DEFGENERIC/DEFMETHOD
.PP
With the defgeneric/defmethod constructs, new generic functions may be
written directly in CLIPS.
Generic functions are similar to deffunctions because they can be used
to define new procedural code directly in CLIPS, and they can be called
like any other function.
However, generic functions are much more powerful because they can do
different things depending on the types (or classes) and number of their
arguments.
For example, a `+' operator could be defined which performs
concatenation for strings but still performs arithmetic addition for
numbers.
Generic functions are comprised of multiple components called methods,
where each method handles different cases of arguments for the generic
function.
A generic function which has more than one method is said to be
overloaded.
.PP
A generic function is comprised of a header (similar to a forward
declaration) and zero or more methods.
A generic function header can either be explicitly declared by the user
or implicitly declared by the definition of at least one method.
The defgeneric construct is used to specify the generic function header,
and the defmethod construct is used for each of the generic
function\[cq]s methods.
.PP
The syntax of the defgeneric/defmethod constructs is:
.IP
.nf
\f[C]
(defgeneric <name> [<comment>])

(defmethod <name> [<index>] [<comment>]
    (<parameter-restriction>* [<wildcard-parameter>])
    <action>*)

<parameter-restriction> ::= <single-field-variable> |
                            (<single-field-variable> <type>* [<query>])

<wildcard-parameter>    ::= <multifield-variable>

<type>                  ::= <class-name>

<query>                 ::= <global-variable> | <function-call>
\f[R]
.fi
.SS DEFCLASS
.PP
A defclass is a construct for specifying the properties (slots) of a
class of objects.
A defclass consists of four elements: 1) a name, 2) a list of
superclasses from which the new class inherits slots and
message-handlers, 3) a specifier saying whether or not the creation of
direct instances of the new class is allowed and 4) a list of slots
specific to the new class.
All user-defined classes must inherit from at least one class, and to
this end COOL provides predefined system classes for use as a base in
the derivation of new classes.
.PP
Any slots explicitly given in the defclass override those gotten from
inheritance.
COOL applies rules to the list of superclasses to generate a class
precedence list for the new class.
Facets further describe slots.
Some examples of facets include: default value, cardinality, and types
of access allowed.
.PP
The syntax of the defclass construct is:
.IP
.nf
\f[C]
(defclass <name> [<comment>]
  (is-a <superclass-name>+)
  [<role>]
  [<pattern-match-role>]
  <slot>*
  <handler-documentation>*)

<role>  ::= (role concrete | abstract)

<pattern-match-role>
        ::= (pattern-match reactive | non-reactive)

<slot>  ::= (slot <name> <facet>*) |
            (single-slot <name> <facet>*) |
            (multislot <name> <facet>*)

<facet> ::=  <default-facet> | <storage-facet> |
             <access-facet> | <propagation-facet> |
             <source-facet> | <pattern-match-facet> |
             <visibility-facet> | <create-accessor-facet>
             <override-message-facet> | <constraint-attributes>

<default-facet> ::=
           (default ?DERIVE | ?NONE | <expression>*) |
           (default-dynamic <expression>*)

<storage-facet> ::= (storage local | shared)

<access-facet>
       ::= (access read-write | read-only | initialize-only)

<propagation-facet> ::= (propagation inherit | no-inherit)

<source-facet> ::= (source exclusive | composite)

<pattern-match-facet>
       ::= (pattern-match reactive | non-reactive)

<visibility-facet> ::= (visibility private | public)

<create-accessor-facet>
     ::= (create-accessor ?NONE | read | write | read-write)

<override-message-facet>
     ::= (override-message ?DEFAULT | <message-name>)

<handler-documentation>
       ::= (message-handler <name> [<handler-type>])

<handler-type> ::= primary | around | before | after
\f[R]
.fi
.SS DEFINSTANCES
.PP
Similar to deffacts, the definstances construct allows the specification
of instances which will be created every time the reset command is
executed.
On every reset all current instances receive a delete message, and the
equivalent of a make-instance function call is made for every instance
specified in definstances constructs.
.PP
The syntax of the definstances construct is:
.IP
.nf
\f[C]
<definstances-construct>
                ::= (definstances <definstances-name> [<comment>]
                       <instance-template>*)

<instance-template>   ::= (<instance-definition>)

<instance-definition> ::= <instance-name-expression> of
                             <class-name-expression>
                             <slot-override>*

<slot-override>       ::= (<slot-name-expression> <expression>*)
\f[R]
.fi
.SS DEFMESSAGE-HANDLER
.PP
Objects are manipulated by sending them messages via the function send.
The result of a message is a useful return-value or side-effect.
A defmessage-handler is a construct for specifying the behavior of a
class of objects in response to a particular message.
The implementation of a message is made up of pieces of procedural code
called message-handlers (or handlers for short).
Each class in the class precedence list of an object\[cq]s class can
have handlers for a message.
In this way, the object\[cq]s class and all its superclasses share the
labor of handling the message.
Each class\[cq]s handlers handle the part of the message which is
appropriate to that class.
Within a class, the handlers for a particular message can be further
subdivided into four types or categories: primary, before, after and
around.
.PP
A defmessage-handler is comprised of seven elements: 1) a class name to
which to attach the handler (the class must have been previously
defined), 2) a message name to which the handler will respond, 3) an
optional type (the default is primary), 4) an optional comment, 5) a
list of parameters that will be passed to the handler during execution,
6) an optional wildcard parameter and 7) a series of expressions which
are executed in order when the handler is called.
The return-value of a message-handler is the evaluation of the last
expression in the body.
.PP
The syntax of the defmessage-handler construct is:
.IP
.nf
\f[C]
(defmessage-handler <class-name> <message-name>
   [<handler-type>] [<comment>]
   (<parameter>* [<wildcard-parameter>])
   <action>*)

<handler-type>       ::= around | before | primary | after

<parameter>          ::= <single-field-variable>

<wildcard-parameter> ::= <multifield-variable>
\f[R]
.fi
.SS DEFMODULE
.PP
CLIPS provides support for the modular development and execution of
knowledge bases with the defmodule construct.
CLIPS modules allow a set of constructs to be grouped together such that
explicit control can be maintained over restricting the access of the
constructs by other modules.
This type of control is similar to global and local scoping used in
languages such as C or Ada.
By restricting access to deftemplate and defclass constructs, modules
can function as blackboards, permitting only certain facts and instances
to be seen by other modules.
Modules are also used by rules to provide execution control.
.PP
The syntax of the defmodule construct is:
.IP
.nf
\f[C]
<defmodule-construct> ::= (defmodule <module-name> [<comment>]
                             <port-spec>*)

<port-specification>  ::= (export <port-item>) |
                          (import <module-name> <port-item>)

<port-item>           ::= ?ALL |
                          ?NONE |
                          <port-construct> ?ALL |
                          <port-construct> ?NONE |
                          <port-construct> <construct-name>+

<port-construct>      ::= deftemplate | defclass |
                          defglobal | deffunction | defgeneric
\f[R]
.fi
.SS CONSTRAINT_ATTRIBUTES
.PP
Constraint attributes can be associated with deftemplate and defclass
slots so that type checking can be performed on slot values when
template facts and instances are created.
The constraint information is also analyzed for the patterns on the LHS
of a rule to determine if the specified constraints prevent the rule
from ever firing.
.PP
The syntax for constraint attributes is:
.IP
.nf
\f[C]
<constraint-attribute> ::= <type-attribute>|
                           <allowed-constant-attribute> |
                           <range-attribute> |
                           <cardinality-attribute>
                           <default-attribute>

<type-attribute>       ::= (type <type-specification>)

<type-specification>   ::= <allowed-type>+ | ?VARIABLE

<allowed-type>         ::= SYMBOL | STRING | LEXEME |
                           INTEGER | FLOAT | NUMBER |
                           INSTANCE-NAME | INSTANCE-ADDRESS |
                           INSTANCE |
                           EXTERNAL-ADDRESS | FACT-ADDRESS

<allowed-constant-attribute>
                       ::= (allowed-symbols<symbol-list>) |
                           (allowed-strings <string-list>) |
                           (allowed-lexemes <lexeme-list> |
                           (allowed-integers<integer-list>) |
                           (allowed-floats<float-list>) |
                           (allowed-numbers<number-list>) |
                           (allowed-instance-names <instance-list>) |
                           (allowed-values<value-list>) |

<symbol-list>          ::= <symbol>+ | ?VARIABLE

<string-list>          ::= <string>+ | ?VARIABLE

<lexeme-list>          ::= <lexeme>+ | ?VARIABLE

<integer-list>         ::= <integer>+ | ?VARIABLE

<float-list>           ::= <float>+ | ?VARIABLE

<number-list>          ::= <number>+ | ?VARIABLE

<instance-name-list>   ::= <instance-name>+ | ?VARIABLE

<value-list>           ::= <constant>+ | ?VARIABLE

<range-attribute>      ::= (range <range-specification>
                                  <range-specification>)

<range-specification>  ::= <number> | ?VARIABLE

<cardinality-attribute>
                    ::= (cardinality <cardinality-specification>
                                     <cardinality-specification>)

<cardinality-specification> ::= <integer> | ?VARIABLE
\f[R]
.fi
.SH FUNCTION_SUMMARY
.PP
This section gives a general overview of the available CLIPS functions.
.IP \[bu] 2
Subtopics: | PREDICATE_FUNCTIONS DEFRULE_FUNCTIONS |
MULTIFIELD_FUNCTIONS AGENDA_FUNCTIONS | STRING_FUNCTIONS
DEFGLOBAL_FUNCTIONS | IO_FUNCTIONS DEFFUNCTION_FUNCTIONS |
MATH_FUNCTIONS GENERIC_FUNCTION_FUNCTIONS | PROCEDURAL_FUNCTIONS
COOL_FUNCTIONS | MISCELLANEOUS_FUNCTIONS DEFMODULE_FUNCTIONS |
DEFTEMPLATE_FUNCTIONS SEQUENCE_EXPANSION_FUNCTIONS | FACT_FUNCTIONS
.SS PREDICATE_FUNCTIONS
.PP
The following functions perform predicate tests and return either TRUE
or FALSE.
.PP
NUMBERP: Returns TRUE for integers and floats.
.PD 0
.P
.PD
> (numberp )
.PP
FLOATP: Returns TRUE for floats.
.PD 0
.P
.PD
> (floatp )
.PP
INTEGERP: Returns TRUE for integers.
.PD 0
.P
.PD
> (integerp )
.PP
LEXEMEP: Returns TRUE for symbols and strings.
.PD 0
.P
.PD
> (numberp )
.PP
STRINGP: Returns TRUE for strings.
.PD 0
.P
.PD
> (stringp )
.PP
SYMBOLP: Returns TRUE for symbols.
.PD 0
.P
.PD
> (symbolp )
.PP
EVENP: Returns TRUE for even numbers.
.PD 0
.P
.PD
> (evenp )
.PP
ODDP: Returns TRUE for odd numbers.
.PD 0
.P
.PD
> (oddp )
.PP
MULTIFIELDP: Returns TRUE for multifield values.
.PD 0
.P
.PD
> (multifieldp )
.PP
POINTERP: Returns TRUE for external addresses.
.PD 0
.P
.PD
> (pointerp )
.PP
EQ: Returns TRUE if the 1st argument is equal in type and value to all
subsequent arguments.
.PD 0
.P
.PD
> (eq +)
.PP
NEQ: Returns TRUE if the 1st argument is not equal in type and value to
all subsequent arguments.
.PD 0
.P
.PD
> (neq +)
.PP
=: Returns TRUE if the 1st argument is equal in value to all subsequent
arguments.
.PD 0
.P
.PD
> (= +)
.PP
<>: Returns TRUE if the 1st argument is not equal in value to all
subsequent arguments.
.PD 0
.P
.PD
> (<> +)
.PP
>: Returns TRUE if each argument is greater in value than the argument
following it.
.PD 0
.P
.PD
> (> +)
.PP
>=: Returns TRUE if each argument is greater than or equal to in value
than the argument following it.
.PD 0
.P
.PD
> (>= +)
.PP
<: Returns TRUE if each argument is less in value than the argument
following it.
.PD 0
.P
.PD
> (< +)
.PP
<=: Returns TRUE if each argument is less than or equal to in value than
the argument following it.
.PD 0
.P
.PD
> (<= +)
.PP
AND: Returns TRUE if all arguments evaluate to a non-FALSE value.
.PD 0
.P
.PD
> (and +)
.PP
OR: Returns TRUE if any argument evaluates to a non-FALSE value.
.PD 0
.P
.PD
> (or +)
.PP
NOT: Returns TRUE if its only argument evaluates to FALSE.
.PD 0
.P
.PD
> (not )
.SS MULTIFIELD_FUNCTIONS
.PP
The following functions operate on multifield values.
.PP
CREATE$: Appends its arguments together to create a multifield value.
.PD 0
.P
.PD
> (create$ *)
.PP
NTH$: Returns the specified field of a multifield value.
.PD 0
.P
.PD
> (nth$ )
.PP
MEMBER$: Returns the position of a single-field value within a
multifield value.
.PD 0
.P
.PD
> (member$ )
.PP
SUBSETP: Returns TRUE if the first argument is a subset of the second
argument.
.PD 0
.P
.PD
> (subsetp )
.PP
DELETE$: Deletes the specified range from a multifield value.
.PD 0
.P
.PD
> (delete$ > )
.PP
EXPLODE$: Creates a multifield value from a string.
.PD 0
.P
.PD
> (explode$ )
.PP
IMPLODE$: Creates a string from a multifield value.
.PD 0
.P
.PD
> (implode$ )
.PP
SUBSEQ$: Extracts the specified range from a multifield value.
.PD 0
.P
.PD
> (subseq$ > )
.PP
REPLACE$: Replaces the specified range of a multifield value with a set
of values.
.PD 0
.P
.PD
> (replace$ > > +)
.PP
INSERT$: Inserts one or more values in a multifield.
.PD 0
.P
.PD
> (insert$ > +)
.PP
FIRST$: Returns the first field of a multifield.
.PD 0
.P
.PD
> (first$ )
.PP
REST$: Returns all but the first field of a multifield.
.PD 0
.P
.PD
> (rest$ )
.PP
LENGTH$: Returns the number of fields in a multifield value.
.PD 0
.P
.PD
> (length$ )
.PP
DELETE-MEMBER$: Deletes specific values contained within a multifield
value and returns the modified multifield value.
.PD 0
.P
.PD
> (delete-member$ +)
.PP
REPLACE-MEMBER$: Replaces specific values contained within a multifield
value and returns the modified multifield value.
.PD 0
.P
.PD
> (replace-member$ > +)
.SS STRING_FUNCTIONS
.PP
The following functions perform operations that are related to strings.
.PP
STR-CAT: Concatenates its arguments to form a single string.
.PD 0
.P
.PD
> (str-cat *)
.PP
SYM-CAT: Concatenates its arguments to form a single symbol.
.PD 0
.P
.PD
> (sym-cat *)
.PP
SUB-STRING: Retrieves a subportion from a string.
.PD 0
.P
.PD
> (sub-string )
.PP
STR-INDEX: Returns the position of the first argument within the second
argument.
.PD 0
.P
.PD
> (str-index )
.PP
EVAL: Evaluates a string as though it were entered at the command
prompt.
.PD 0
.P
.PD
Only allows functions to be evaluated.
> (eval )
.PP
BUILD: Evaluates a string as though it were entered at the command
prompt.
Only allows constructs to be evaluated.
.PD 0
.P
.PD
> (build )
.PP
UPCASE: Converts lowercase characters in a string or symbol to
uppercase.
.PD 0
.P
.PD
> (upcase )
.PP
LOWCASE: Converts uppercase characters in a string or symbol to
lowercase.
.PD 0
.P
.PD
> (lowcase )
.PP
STR-COMPARE: Lexigraphically compares two strings.
.PD 0
.P
.PD
> (str-compare )
.PP
STR-LENGTH: Returns the length of a string.
.PD 0
.P
.PD
> (str-length )
.PP
CHECK-SYNTAX: Allows the text representation of a construct or function
call to be checked for syntax and semantic errors.
.PD 0
.P
.PD
> (check-syntax )
.PP
STRING-TO-FIELD: Parses a string and converts its contents to a
primitive data type.
.PD 0
.P
.PD
> (string-to-field )
.SS IO_FUNCTIONS
.PP
The following functions perform I/O operations.
.PP
OPEN: Opens a file.
.PD 0
.P
.PD
> (open []) > ::= \[lq]r\[rq] | \[lq]w\[rq] | \[lq]r+\[rq] | \[lq]a\[rq]
| \[lq]wb\[rq]
.PP
CLOSE: Closes a file.
.PD 0
.P
.PD
> (close [])
.PP
PRINTOUT: Sends unformated output to the specified logical name.
.PD 0
.P
.PD
> (printout *)
.PP
READ: Reads a single-field value from the specified logical name.
.PD 0
.P
.PD
> (read [])
.PP
READLINE: Reads an entire line as a string from the specified logical
name.
.PD 0
.P
.PD
> (readline [])
.PP
FORMAT: Sends formated output to the specified logical name.
.PD 0
.P
.PD
> (format *)
.PP
RENAME: Changes the name of a file.
.PD 0
.P
.PD
> (rename )
.PP
REMOVE: Deletes a file.
.PD 0
.P
.PD
> (remove )
.PP
GET-CHAR: Allows a single character to be retrieved from a logical name.
.PD 0
.P
.PD
> (get-char [])
.PP
READ-NUMBER: Allows a user to input a single number using the localized
format.
.PD 0
.P
.PD
> (read-number [])
.PP
SET-LOCALE: Allows a locale to be specified for the numeric format
behavior of the format and read-number functions.
.PD 0
.P
.PD
> (set-locale [])
.SS MATH_FUNCTIONS
.PP
The math functions have been divided into three broad categories.
The basic math functions are always provided with CLIPS.
The trigonometric and extended math functions are included as part of
the extended math package.
.PP
Subtopics:
.PD 0
.P
.PD
\ \ \ \ BASIC_MATH_FUNCTIONS EXTENDED_MATH_FUNCTIONS
.PD 0
.P
.PD
\ \ \ \ TRIGONOMETRIC_FUNCTIONS
.SS BASIC_MATH_FUNCTIONS
.PP
The following functions perform basic mathematical operations.
.PP
+: Returns the sum of its arguments.
.PD 0
.P
.PD
> (+ +)
.PP
-: Returns the first argument minus all subsequent arguments.
.PD 0
.P
.PD
> (- +)
.PP
*: Returns the product of its arguments.
.PD 0
.P
.PD
> (* +)
.PP
/: Returns the first argument divided by all subsequent arguments.
.PD 0
.P
.PD
> (/ +)
.PP
DIV: Returns the first argument divided by all subsequent arguments
.PD 0
.P
.PD
using integer division.
> (div +)
.PP
MAX: Returns the value of its largest numeric argument.
.PD 0
.P
.PD
> (max +)
.PP
MIN: Returns the value of its smallest numeric argument.
.PD 0
.P
.PD
> (min +)
.PP
ABS: Returns the absolute value of its only argument.
.PD 0
.P
.PD
> (abs )
.PP
FLOAT: Converts its only argument to a float.
.PD 0
.P
.PD
> (float )
.PP
INTEGER: Converts its only argument to an integer.
.PD 0
.P
.PD
> (integer )
.SS TRIGONOMETRIC_FUNCTIONS
.PP
The following trigonometric functions take one numeric argument and
return a float.
The argument is expected to be in radians.
These functions are part of the extended math package.
.IP
.nf
\f[C]
    FUNCTION         RETURNS
    -----------------------------------
    acos             arccosine
    acosh            hyperbolic arccosine
    acot             arccotangent
    acoth            hyperbolic arccotangent
    acsc             arccosecant
    acsch            hyperbolic arccosecant
    asec             arcsecant
    asech            hyperbolic arcsecant
    asin             arcsine
    asinh            hyperbolic arcsine
    atan             arctangent
    atanh            hyperbolic arctangent
    cos              cosine
    cosh             hyperbolic cosine
    cot              cotangent
    coth             hyperbolic tangent
    csc              cosecant
    csch             hyperbolic cosecant
    sec              secant
    sech             hyperbolic secant
    sin              sine
    sinh             hyperbolic sine
    tan              tangent
    tanh             hyperbolic tangent
\f[R]
.fi
.SS EXTENDED_MATH_FUNCTIONS
.PP
The following functions perform extended mathematical operations and are
included as part of the extended math package.
.PP
DEG-GRAD: Converts its only argument from degrees to gradients.
.PD 0
.P
.PD
> (deg-grad )
.PP
DEG-RAD: Converts its only argument from degrees to radians.
.PD 0
.P
.PD
> (deg-rad )
.PP
GRAD-DEG: Converts its only argument from gradients to degrees.
.PD 0
.P
.PD
> (grad-deg )
.PP
RAD-DEG: Converts its only argument from radians to degrees.
.PD 0
.P
.PD
> (rad-deg )
.PP
PI: Returns the value of pi.
.PD 0
.P
.PD
> (pi)
.PP
SQRT: Returns the square root of its only argument.
.PD 0
.P
.PD
> (sqrt )
.PP
**: Raises its first argument to the power of its second argument.
.PD 0
.P
.PD
> (** )
.PP
EXP: Raises the value e to the power of its only argument.
.PD 0
.P
.PD
> (exp )
.PP
LOG: Returns the logarithm base e of its only argument.
.PD 0
.P
.PD
> (log )
.PP
LOG10: Returns the logarithm base 10 of its only argument.
.PD 0
.P
.PD
> (log10 )
.PP
ROUND: Rounds its argument toward the closest integer or negative
infinity if exactly between two integers.
.PD 0
.P
.PD
> (round )
.PP
MOD: Returns the remainder of the result of dividing its first argument
by its second argument (assuming that the result of division must be an
integer).
.PD 0
.P
.PD
> (mod )
.SS PROCEDURAL_FUNCTIONS
.PP
The following are functions which provide procedural programming
capabilities as found in languages such as Pascal, C, and Ada.
.PP
BIND: Binds a variable to a new value.
.PD 0
.P
.PD
> (bind *)
.PP
IF: Allows conditional execution of a group of actions.
.PD 0
.P
.PD
> (if then * [else *])
.PP
WHILE: Allows conditional looping.
.PD 0
.P
.PD
> (while [do] *)
.PP
LOOP-FOR-COUNT: Allows simple iterative looping.
.PD 0
.P
.PD
> (loop-for-count [do] *) > ::= | > ( [ ]) > ::= > ::=
.PP
PROGN: Evaluates all arguments and returns the value of the last
argument evaluated.
.PD 0
.P
.PD
> (progn *)
.PP
PROGN\[u2004]:\[u2004]\f[I]P\f[R]\f[I]e\f[R]\f[I]r\f[R]\f[I]f\f[R]\f[I]o\f[R]\f[I]r\f[R]\f[I]m\f[R]\f[I]s\f[R]\f[I]a\f[R]\f[I]s\f[R]\f[I]e\f[R]\f[I]t\f[R]\f[I]o\f[R]\f[I]f\f[R]\f[I]a\f[R]\f[I]c\f[R]\f[I]t\f[R]\f[I]i\f[R]\f[I]o\f[R]\f[I]n\f[R]\f[I]s\f[R]\f[I]f\f[R]\f[I]o\f[R]\f[I]r\f[R]\f[I]e\f[R]\f[I]a\f[R]\f[I]c\f[R]\f[I]h\f[R]\f[I]f\f[R]\f[I]i\f[R]\f[I]e\f[R]\f[I]l\f[R]\f[I]d\f[R]\f[I]o\f[R]\f[I]f\f[R]\f[I]a\f[R]\f[I]m\f[R]\f[I]u\f[R]\f[I]l\f[R]\f[I]t\f[R]\f[I]i\f[R]\f[I]f\f[R]\f[I]i\f[R]\f[I]e\f[R]\f[I]l\f[R]\f[I]d\f[R]\f[I]v\f[R]\f[I]a\f[R]\f[I]l\f[R]\f[I]u\f[R]\f[I]e\f[R].\[u2004]>\[u2004](\f[I]p\f[R]\f[I]r\f[R]\f[I]o\f[R]\f[I]g\f[R]\f[I]n\f[R]
*) > ::= | > ( )
.PP
RETURN: Immediately terminates the currently executing deffunction,
generic function method, message-handler, defrule RHS, or certain
instance set query functions and if a value is specified, returns this
value as the result of the executing construct.
.PD 0
.P
.PD
> (return [])
.PP
BREAK: Immediately terminates the currently iterating while loop, progn
execution, or certain instance set query functions.
.PD 0
.P
.PD
> (break)
.PP
SWITCH: Allows a particular group of actions to be performed based on a
specified value.
.IP
.nf
\f[C]
 (switch <test-expression>
    <case-statement>*
    [<default-statement>])
 <case-statement> ::= (case <comparison-expression> then <action>*)
 <default-statement> ::= (default <action>*)
\f[R]
.fi
.SS MISCELLANEOUS_FUNCTIONS
.PP
The following are additional functions for use within CLIPS.
.PP
GENSYM: Returns a special sequenced symbol.
.PD 0
.P
.PD
> (gensym)
.PP
GENSYM\f[I]: Returns a special unique sequenced symbol.
.PD 0
.P
.PD
> (gensym\f[R])
.PP
SETGEN: Sets the starting number used by gensym and gensym*.
.PD 0
.P
.PD
> (setgen )
.PP
RANDOM: Returns a \[lq]random\[rq] integer value.
.PD 0
.P
.PD
> (random [ ])
.PP
SEED: Seeds the random number generator used by random.
.PD 0
.P
.PD
> (seed )
.PP
TIME: Returns a float representing the elapsed seconds since the system
reference time.
.PD 0
.P
.PD
> (time)
.PP
LENGTH: Returns an integer for the number of fields in a multifield
value or the length in characters of a string or symbol.
.PD 0
.P
.PD
> (length )
.PP
GET-FUNCTION_RESTRICTIONS: Returns the restriction string associated
with a CLIPS or user defined function.
.PD 0
.P
.PD
> (get-function-restrictions )
.PP
SORT: Allows a list of values to be sorted based on a user specified
comparison function.
.PD 0
.P
.PD
> (sort *)
.PP
FUNCALL: Constructs a function call from its arguments and then
evaluates the function call.
.PD 0
.P
.PD
> (funcall (function-name> *)
.PP
TIMER: Returns the number of seconds elapsed evaluating a series of
expressions.
.PD 0
.P
.PD
> (timer *)
.SS DEFTEMPLATE_FUNCTIONS
.PP
The following functions provide ancillary capabilities for the
deftemplate construct.
.PP
DEFTEMPLATE-MODULE: Returns the module in which the specified
deftemplate is defined.
.PD 0
.P
.PD
> (deftemplate-module )
.PP
DEFTEMPLATE-SLOT-ALLOWED-VALUES: Returns a multifield containing the
allowed values for a deftemplate slot.
.PD 0
.P
.PD
> (deftemplate-slot-allowed-values )
.PP
DEFTEMPLATE-SLOT-CARDINALITY: Returns a multifield containing the
minimum and maximum cardinality allowed for a multifield slot.
.PD 0
.P
.PD
> (deftemplate-slot-cardinality )
.PP
DEFTEMPLATE-SLOT-DEFAULTP: Returns either static, dynamic, or FALSE to
indicate whether the deftemplate slot has a default.
.PD 0
.P
.PD
> (deftemplate-slot-defaultp )
.PP
DEFTEMPLATE-SLOT-DEFAULT-VALUE: Returns the default value for the
deftemplate slot.
.PD 0
.P
.PD
> (deftemplate-slot-default-value )
.PP
DEFTEMPLATE-SLOT-EXISTP: Returns TRUE if the specified deftemplate slot
exists, otherwise FALSE.
.PD 0
.P
.PD
> (deftemplate-slot-existp )
.PP
DEFTEMPLATE-SLOT-MULTIP: Returns TRUE if the specified deftemplate slot
is a multifield slot, otherwise FALSE.
.PD 0
.P
.PD
> (deftemplate-slot-multip )
.PP
DEFTEMPLATE-SLOT-NAMES: Returns the slot names associated with the
deftemplate in a multifield value.
.PD 0
.P
.PD
> (deftemplate-slot-names )
.PP
DEFTEMPLATE-SLOT-RANGE: Returns a multifield containing the minimum and
maximum numeric range allowed for a slot.
.PD 0
.P
.PD
> (deftemplate-slot-range )
.PP
DEFTEMPLATE-SLOT-SINGLEP: Returns TRUE if the specified deftemplate slot
is a single-field slot, otherwise FALSE.
.PD 0
.P
.PD
> (deftemplate-slot-singlep )
.PP
DEFTEMPLATE-SLOT-TYPES: Returns a multifield containing the primitive
types allowed for a slot.
.PD 0
.P
.PD
> (deftemplate-slot-types )
.PP
GET-DEFTEMPLATE-LIST: Returns the list of all deftemplates in the
specified module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-deftemplate-list [])
.SS ENTRY-FACT_FUNCTIONS
.PP
The following actions are used for assert, retracting, and modifying
facts.
.PP
ASSERT: Adds a fact to the fact-list.
.PD 0
.P
.PD
> (assert +)
.PP
RETRACT: Removes a fact from the fact-list.
.IP
.nf
\f[C]
 (retract <retract-specifier>+ | *)
 <retract-specifier> ::= <fact-specifier> | <integer-expression>
\f[R]
.fi
.PP
MODIFY: Modifies a deftemplate fact in the fact-list.
.PD 0
.P
.PD
> (modify *)
.PP
DUPLICATE: Duplicates a deftemplate fact in the fact-list.
.PD 0
.P
.PD
> (duplicate *)
.PP
ASSERT-STRING: Converts a string into a fact and asserts it.
.PD 0
.P
.PD
> (assert-string )
.PP
FACT-INDEX: Returns the fact index of a fact address.
.PD 0
.P
.PD
> (fact-index )
.PP
FACT-EXISTP: Returns TRUE if the fact specified by its fact-index or
fact-address arguments exists, otherwise FALSE.
.PD 0
.P
.PD
> (fact-existp )
.PP
FACT-RELATION: Returns the deftemplate (relation) name associated with
the fact.
.PD 0
.P
.PD
> (fact-relation )
.PP
FACT-SLOT-NAMES: Returns the slot names associated with the fact.
.PD 0
.P
.PD
> (fact-slot-names )
.PP
FACT-SLOT-VALUE: Returns the value of the specified slot from the
specified fact.
.PD 0
.P
.PD
> (fact-slot-value )
.PP
GET-FACT-LIST: Returns a multifield containing the list of visible
facts.
.PD 0
.P
.PD
> (get-fact-list [])
.SS DEFFACTS_FUNCTIONS
.PP
The following functions provide ancillary capabilities for the deffacts
construct.
.PP
GET-DEFFACTS-LIST: Returns the list of all deffacts in the specified
module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-deffacts-list [])
.PP
DEFFACTS-MODULE: Returns the module in which the specified deffacts is
defined.
.PD 0
.P
.PD
> (deffacts-module )
.SS DEFRULE_FUNCTIONS
.PP
The following functions provide ancillary capabilities for the defrule
construct.
.PP
GET-DEFRULE-LIST: Returns the list of all defrules in the specified
module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-defrule-list [])
.PP
DEFRULE-MODULE: Returns the module in which the specified defrule is
defined.
.PD 0
.P
.PD
> (defrule-module )
.SS AGENDA_FUNCTIONS
.PP
The following functions provide ancillary capabilities for manipulating
the agenda.
.PP
GET-FOCUS: Returns the module name of the current focus.
.PD 0
.P
.PD
> (get-focus)
.PP
GET-FOCUS-STACK: Returns all of the module names in the focus stack as a
multifield value.
.PD 0
.P
.PD
> (get-focus-stack)
.PP
POP-FOCUS: Removes the current focus from the focus stack and returns
the module name of the current focus.
.PD 0
.P
.PD
> (pop-focus)
.SS DEFGLOBAL_FUNCTIONS
.PP
The following functions provide ancillary capabilities for the defglobal
construct.
.PP
GET-DEFGLOBAL-LIST: Returns the list of all defglobals in the specified
module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-defglobal-list [])
.PP
DEFGLOBAL-MODULE: Returns the module in which the specified defglobal is
defined.
.PD 0
.P
.PD
> (defglobal-module )
.SS DEFFUNCTION_FUNCTIONS
.PP
The following functions provide ancillary capabilities for the
deffunction construct.
.PP
GET-DEFFUNCTION-LIST: Returns the list of all deffunctions in the
specified module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-deffunction-list [])
.PP
DEFFUNCTION-MODULE: Returns the module in which the specified
deffunction is defined.
.PD 0
.P
.PD
> (deffunction-module )
.SS GENERIC_FUNCTION_FUNCTIONS
.PP
The following functions provide ancillary capabilities for generic
function methods.
.PP
GET-DEFGENERIC-LIST: Returns the list of all defgenerics in the
specified module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-defgeneric-list [])
.PP
DEFGENERIC-MODULE: Returns the module in which the specified defgeneric
is defined.
.PD 0
.P
.PD
> (defgeneric-module )
.PP
GET-DEFMETHOD-LIST: Returns the list of all defmethods in the current
module (or just the methods associated with the specified defgeneric).
.PD 0
.P
.PD
> (get-defmethod-list [])
.PP
TYPE: Returns a symbol which is the name of the type (or class) of its
of argument.
.PD 0
.P
.PD
> (type )
.PP
NEXT-METHODP: If called from a method for a generic function, the
function next-methodp will return the symbol TRUE if there is another
method shadowed by the current one.
Otherwise, the function will return the symbol FALSE.
.PD 0
.P
.PD
> (next-methodp)
.PP
CALL-NEXT-METHOD: Calls the next shadowed method.
.PD 0
.P
.PD
> (call-next-method)
.PP
OVERRIDE-NEXT-METHOD: Calls the next shadowed method allowing new
arguments to be provided.
.PD 0
.P
.PD
> (override-next-method *)
.PP
CALL-SPECIFIC-METHOD: Calls a particular method of a generic function
without regards to method precedence.
.PD 0
.P
.PD
> (call-specific-method *)
.PP
GET-METHOD-RESTRICTIONS: Returns a multifield value containing
information about the restrictions for the specified method.
.PD 0
.P
.PD
> (get-method-restrictions )
.SS COOL_FUNCTIONS
.PP
The functions manipulating the CLIPS Object-Oriented Language (COOL) are
divided into five categories.
.PP
Subtopics:
.PD 0
.P
.PD
CLASS_FUNCTIONS INSTANCE_SLOT_FUNCTIONS
.PD 0
.P
.PD
INSTANCE_MANIPULATION_FUNCTIONS MESSAGE-HANDLER_FUNCTIONS
.PD 0
.P
.PD
DEFINSTANCES_FUNCTIONS INSTANCE_PREDICATE_FUNCTIONS
.SS CLASS_FUNCTIONS
.PP
The following functions are used with classes.
.PP
GET-DEFCLASS-LIST: Returns the list of all defclasses in the specified
module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-defclass-list [])
.PP
DEFCLASS-MODULE: Returns the module in which the specified defclass is
defined.
.PD 0
.P
.PD
> (defclass-module )
.PP
CLASS-EXISTP: Returns TRUE if the specified class is defined, FALSE
otherwise.
.PD 0
.P
.PD
> (class-existp )
.PP
SUPERCLASSP: Returns TRUE if the first class is a superclass of the
second class, FALSE otherwise.
.PD 0
.P
.PD
> (superclassp )
.PP
SUBCLASSP: Returns TRUE if the first class is a subclass of the second
class, FALSE otherwise.
.PD 0
.P
.PD
> (subclassp )
.PP
SLOT-EXISTP: Returns TRUE if the specified slot is present in the class,
FALSE otherwise.
If the inherit keyword is specified, then the slot may be inherited.
.PD 0
.P
.PD
> (slot-existp [inherit])
.PP
SLOT-WRITABLEP: Returns TRUE if the specified slot is writable,
otherwise FALSE.
.PD 0
.P
.PD
> (slot-writablep )
.PP
SLOT-INITABLEP: Returns TRUE if the specified slot is initializable,
otherwise FALSE.
.PD 0
.P
.PD
> (slot-initablep )
.PP
SLOT-PUBLICP: Returns TRUE if the specified slot is public, otherwise
FALSE.
.PD 0
.P
.PD
> (slot-initablep )
.PP
SLOT-DIRECT-ACCESSP: Returns TRUE if the specified slot can be accessed
directly, otherwise FALSE.
.PD 0
.P
.PD
> (slot-direct-accessp )
.PP
MESSAGE-HANDLER-EXISTP: Returns TRUE if the specified message-handler is
defined (directly, not by inheritance) for the class, FALSE otherwise.
.PD 0
.P
.PD
> (message-handler-existp []) > ::= around | before | primary | after
.PP
CLASS-ABSTRACTP: Returns TRUE if the specified class is abstract, FALSE
otherwise.
.PD 0
.P
.PD
> (class-abstractp )
.PP
CLASS-REACTIVEP: Returns TRUE if the specified class is reactive, FALSE
otherwise.
.PD 0
.P
.PD
> (class-reactivep )
.PP
CLASS-SUPERCLASSES: Returns the names of the direct superclasses of a
class in a multifield variable.
If the optional \[lq]inherit\[rq] argument is given, indirect
superclasses are also included.
.PD 0
.P
.PD
> (class-superclasses [inherit])
.PP
CLASS-SUBCLASSES: Returns the names of the direct subclasses of a class
in a multifield variable.
If the optional \[lq]inherit\[rq] argument is given, indirect subclasses
are also included.
.PD 0
.P
.PD
> (class-subclasses [inherit])
.PP
CLASS-SLOTS: Returns the names of the explicitly defined slots of a
class in a multifield variable.
If the optional inherit keyword is given, inherited slots are also
included.
.PD 0
.P
.PD
> (class-slots [inherit])
.PP
GET-DEFMESSAGE-HANDLER-LIST: Returns the class names, message names, and
message types of the message-handlers directly attached to a class in a
multifield variable.
If the optional inherit keyword is given, inherited message-handlers are
also included.
.PD 0
.P
.PD
> (get-defmessage-handler-list [inherit])
.PP
SLOT-FACETS: Returns the facet values for the specified slot of a class
in a multifield value.
.PD 0
.P
.PD
> (slot-facets )
.PP
SLOT-SOURCES: Returns the names of the classes which provide facets for
a slot of a class in a multifield variable.
.PD 0
.P
.PD
> (slot-sources )
.PP
SLOT-TYPES: Returns the names of the primitive types allowed for a slot
in a multifield variable.
.PD 0
.P
.PD
> (slot-types )
.PP
SLOT-CARDINALITY: Returns the minimum and maximum number of fields
allowed for a multislot in a multifield variable.
.PD 0
.P
.PD
> (slot-cardinality )
.PP
SLOT-ALLOWED-VALUES: Returns the allowed values for a slot in a
multifield value.
.PD 0
.P
.PD
> (slot-allowed-values )
.PP
SLOT-RANGE: Returns the minimum and maximum numeric values allowed for a
slot.
.PD 0
.P
.PD
> (slot-range )
.PP
SLOT-DEFAULT-VALUE: Returns the default value associated with a slot.
> (slot-default-value )
.PP
SET-CLASS-DEFAULTS-MODE: Sets the defaults mode used when classes are
defined.
.PD 0
.P
.PD
> (set-class-defaults-mode ) > ::= convenience | conservation
.PP
GET-CLASS-DEFAULTS-MODE: Returns the current defaults mode used when
classes are defined.
.PD 0
.P
.PD
> (get-class-defaults-mode)
.PP
SLOT-ALLOWED-CLASSES: Returns the allowed classes for a slot in a
multifield value.
.PD 0
.P
.PD
> (slot-allowed-classes )
.SS MESSAGE-HANDLER_FUNCTIONS
.PP
The following functions are used with message-handlers.
.PP
NEXT-HANDLERP: Returns TRUE if there is another message-handler
available for execution, FALSE otherwise.
.PD 0
.P
.PD
> (next-handlerp)
.PP
CALL-NEXT-HANDLER: Calls the next shadowed handler.
.PD 0
.P
.PD
> (call-next-handler)
.PP
OVERRIDE-NEXT-HANDLER: Calls the next shadowed handler and allows the
arguments to be changed.
.PD 0
.P
.PD
> (override-next-handler *)
.SS DEFINSTANCES_FUNCTIONS
.PP
The following functions are used with definstances.
.PP
GET-DEFINSTANCES-LIST: Returns the list of all definstances in the
specified module (or the current module if unspecified).
.PD 0
.P
.PD
> (get-definstances-list [])
.PP
DEFINSTANCES-MODULE: Returns the module in which the specified
definstance is defined.
.PD 0
.P
.PD
> (definstances-module )
.SS INSTANCE_MANIPULATION_FUNCTIONS
.PP
The following manipulation functions are used with instances.
.PP
INIT-SLOTS: Implements the init message-handler attached to the class
USER.
This function should never be called directly unless an init
message-handler is being defined such that the one attached to USER will
never be called.
.PD 0
.P
.PD
> (init-slots)
.PP
UNMAKE-INSTANCE: Deletes the specified instance by sending it the delete
message.
.PD 0
.P
.PD
> (unmake-instance | *)
.PP
DELETE-INSTANCE: Deletes the active instance when called from within the
body of a message-handler.
.PD 0
.P
.PD
> (delete-instance)
.PP
CLASS: Returns a symbol which is the name of the class of its argument.
.PD 0
.P
.PD
> (class )
.PP
INSTANCE-NAME: Returns a symbol which is the name of its instance
argument.
.PD 0
.P
.PD
> (instance-name )
.PP
INSTANCE-ADDRESS: Returns the address of its instance argument.
.PD 0
.P
.PD
> (instance-address )
.PP
SYMBOL-TO-INSTANCE-NAME: Converts a symbol to an instance name.
.PD 0
.P
.PD
> (symbol-to-instance-name )
.PP
INSTANCE-NAME-TO-SYMBOL: Converts an instance name to a symbol.
.PD 0
.P
.PD
> (instance-name-to-symbol )
.SS INSTANCE_PREDICATE_FUNCTIONS
.PP
The following predicate functions are used with instances.
.PP
INSTANCEP: Returns TRUE if its argument is an instance name or instance
address, FALSE otherwise.
.PD 0
.P
.PD
> (instancep )
.PP
INSTANCE-ADDRESSP: Returns TRUE if its argument is an instance address,
FALSE otherwise.
.PD 0
.P
.PD
> (instance-addressp )
.PP
INSTANCE-NAMEP: Returns TRUE if its argument is an instance name, FALSE
otherwise.
.PD 0
.P
.PD
> (instance-namep )
.PP
INSTANCE-EXISTP: Returns TRUE if the specified instance exists, FALSE
otherwise.
.PD 0
.P
.PD
> (instance-existp )
.SS INSTANCE_SLOT_FUNCTIONS
.PP
The following functions are used to manipulate instance slots.
.PP
DYNAMIC-GET: Returns the value of the specified slot of the active
instance.
.PD 0
.P
.PD
> (dynamic-get )
.PP
DYNAMIC-PUT: Sets the value of the specified slot of the active
instance.
.PD 0
.P
.PD
> (put *)
.PP
SLOT-REPLACE$: Allows the replacement of a range of fields in a
multifield slot value.
.PD 0
.P
.PD
> (slot-replace$ > +)
.PP
DIRECT-SLOT-REPLACE$: Allows the replacement of a range of fields in a
multifield slot value of the active instance from within a
message-handler.
.PD 0
.P
.PD
> (direct-slot-replace$ +)
.PP
SLOT-INSERT$: Allows the insertion of one or more values in a multifield
slot value.
.PD 0
.P
.PD
> (slot-insert$ +)
.PP
DIRECT-SLOT-INSERT$: Allows the insertion of one or more values in a
multifield slot value of the active instance from within a
message-handler.
.PD 0
.P
.PD
> (direct-slot-insert$ +)
.PP
SLOT-DELETE$: Allows the deletion of a range of fields in a multifield
slot value.
.PD 0
.P
.PD
> (slot-delete$ )
.PP
DIRECT-SLOT-DELETE$: Allows the deletion of a range of fields in a
multifield slot value of the active instance from within a
message-handler.
.PD 0
.P
.PD
> (direct-slot-delete$ )
.SS DEFMODULE_FUNCTIONS
.PP
The following functions provide ancillary capabilities for the defmodule
construct.
.PP
GET-DEFMODULE-LIST: Returns the list of all defmodules.
.PD 0
.P
.PD
> (get-defmodule-list)
.SS SEQUENCE_EXPANSION_FUNCTIONS
.PP
The following functions provide ancillary capabilities for the sequence
expansion operator.
.PP
EXPAND$: When used inside of a function call, expands its arguments as
separate arguments to the function.
The $ operator is merely a shorthand notation for the expand$ function
call.
.PD 0
.P
.PD
> (expand$ )
.PP
SET-SEQUENCE-OPERATOR-RECOGNITION: Sets the sequence operator
recognition behavior.
.PD 0
.P
.PD
> (set-sequence-operator-recognition )
.PP
GET-SEQUENCE-OPERATOR-RECOGNITION: Returns the current value of the
sequence operator recognition behavior.
.PD 0
.P
.PD
> (get-sequence-operator-recognition)
.SH COMMAND_SUMMARY
.PP
This section gives a general overview of the available CLIPS commands.
.PP
Subtopics:
.PD 0
.P
.PD
\ \ \ \ ENVIRONMENT_COMMANDS DEFFUNCTION_COMMANDS
.PD 0
.P
.PD
\ \ \ \ DEBUGGING_COMMANDS GENERIC_FUNCTION_COMMANDS
.PD 0
.P
.PD
\ \ \ \ DEFTEMPLATE_COMMANDS COOL_COMMANDS
.PD 0
.P
.PD
\ \ \ \ FACT_COMMANDS DEFMODULE_COMMANDS
.PD 0
.P
.PD
\ \ \ \ DEFFACTS_COMMANDS MEMORY_COMMANDS
.PD 0
.P
.PD
\ \ \ \ DEFRULE_COMMANDS TEXT_PROCESSING_COMMANDS
.PD 0
.P
.PD
\ \ \ \ AGENDA_COMMANDS PROFILING_COMMANDS
.PD 0
.P
.PD
\ \ \ \ DEFGLOBAL_COMMANDS
.SS ENVIRONMENT_COMMANDS
.PP
The following commands control the CLIPS environment.
.PP
LOAD: Loads constructs from a file.
.PD 0
.P
.PD
> (load )
.PP
LOAD\f[I]: Loads constructs from a file without displaying informational
messages.
.PD 0
.P
.PD
> (load\f[R] )
.PP
SAVE: Saves constructs to a file.
.PD 0
.P
.PD
> (save )
.PP
BLOAD: Loads a binary image from a file.
.PD 0
.P
.PD
> (bload )
.PP
BSAVE: Saves a binary image to a file.
.PD 0
.P
.PD
> (bsave )
.PP
CLEAR: Clears the CLIPS environment.
.PD 0
.P
.PD
> (clear)
.PP
EXIT: Exits the CLIPS environment.
.PD 0
.P
.PD
> (exit)
.PP
RESET: Resets the CLIPS environment.
.PD 0
.P
.PD
> (reset)
.PP
BATCH: Executes commands from a file.
.PD 0
.P
.PD
> (batch )
.PP
BATCH\f[I]: Executes commands from a file. Unlike the batch command,
evaluates all of the commands in the specified file before returning
rather than replacing standard input.
.PD 0
.P
.PD
> (batch\f[R] )
.PP
OPTIONS: Lists the settings of CLIPS compiler flags.
.PD 0
.P
.PD
> (options)
.PP
SYSTEM: Appends its arguments together to form a command which is then
sent to the operating system.
.PD 0
.P
.PD
> (system *)
.PP
SET-AUTO-FLOAT-DIVIDEND: Sets the auto-float dividend behaviour.
.PD 0
.P
.PD
> (set-auto-float-dividend )
.PP
GET-AUTO-FLOAT-DIVIDEND: Returns the current value of the auto-float
dividend behaviour.
.PD 0
.P
.PD
> (get-auto-float-dividend)
.PP
SET-DYNAMIC-CONSTRAINT-CHECKING: Sets the dynamic constraint checking
behaviour.
.PD 0
.P
.PD
> (set-dynamic-constraint-checking )
.PP
GET-DYNAMIC-CONSTRAINT-CHECKING: Returns the current value of the
dynamic constraint checking behaviour.
.PD 0
.P
.PD
> (get-dynamic-constraint-checking)
.PP
SET-STATIC-CONSTRAINT-CHECKING: Sets the static constraint checking
behaviour.
.PD 0
.P
.PD
> (set-static-constraint-checking )
.PP
GET-STATIC-CONSTRAINT-CHECKING: Returns the current value of the static
constraint checking behaviour.
.PD 0
.P
.PD
> (get-static-constraint-checking)
.PP
APROPOS: Displays all symbols currently defined in CLIPS which contain a
specified substring
.PD 0
.P
.PD
> (apropos )
.SS DEBUGGING_COMMANDS
.PP
The following commands control the CLIPS debugging features.
.PP
DRIBBLE-ON: Sends trace information to the specified file.
.PD 0
.P
.PD
> (dribble-on )
.PP
DRIBBLE-OFF: Closes the trace file.
.PD 0
.P
.PD
> (dribble-off)
.PP
WATCH: Enables trace information for the specified item.
.PD 0
.P
.PD
> (watch )
.IP
.nf
\f[C]
<watch-item> ::= all |
                 compilations |
                 statistics |
                 focus |
                 messages |
                 deffunctions <deffunction-name>* |
                 globals <global-name>* |
                 rules <rule-name>* |
                 activations <rule-name>* |
                 facts <deftemplate-name>* |
                 instances <class-name>* |
                 slots <class-name>* |
                 message-handlers <handler-spec-1>* [<handler-spec-2>]) |
                 generic-functions <generic-name>* |
                 methods <method-spec-1>* [<method-spec-2>]

<handler-spec-1> ::= <class-name> <handler-name> <handler-type>
<handler-spec-2> ::= <class-name> [<handler-name> [<handler-type>]]

<method-spec-1> ::= <generic-name> <method-index>
<method-spec-2> ::= <generic-name> [<method-index>]
\f[R]
.fi
.PP
UNWATCH: Disables trace information for the specified item.
.PD 0
.P
.PD
> (unwatch )
.PP
LIST-WATCH-ITEMS: Displays the current state of watch items.
.PD 0
.P
.PD
> (list-watch-items [])
.SS DEFTEMPLATE_COMMANDS
.PP
The following commands manipulate deftemplates.
.PP
PPDEFTEMPLATE: Displays the text of a given deftemplate.
.PD 0
.P
.PD
> (ppdeftemplate )
.PP
LIST-DEFTEMPLATES: Displays the list of all deftemplates in the
specified module (or the current module if none specified).
.PD 0
.P
.PD
> (list-deftemplates [])
.PP
UNDEFTEMPLATE: Deletes a deftemplate.
.PD 0
.P
.PD
> (undeftemplate )
.SS FACT_COMMANDS
.PP
The following commands display information about facts.
.PP
FACTS: Display the facts in the fact-list.
.PD 0
.P
.PD
> (facts [] > [ > [ > []]])
.PP
LOAD-FACTS: Asserts facts loaded from a file.
.PD 0
.P
.PD
> (load-facts )
.PP
SAVE-FACTS: Saves facts to a file.
.PD 0
.P
.PD
> (save-facts [ *]) > ::= visible | local
.PP
DEPENDENCIES: Lists the partial matches from which a fact or instance
receives logical support.
.PD 0
.P
.PD
> (dependencies )
.PP
DEPENDENTS: Lists all facts or instances which receive logical support
from a fact or instance.
.PD 0
.P
.PD
> (dependents )
.PP
SET-FACT-DUPLICATION: Sets the fact duplication behavior.
.PD 0
.P
.PD
> (set-fact-duplication )
.PP
GET-FACT-DUPLICATION: Returns the fact duplication behavior.
.PD 0
.P
.PD
> (get-fact-duplication)
.PP
PPFACT: Displays the text of a given fact.
.PD 0
.P
.PD
> (ppfact [ []])
.SS DEFFACTS_COMMANDS
.PP
The following commands manipulate deffacts.
.PP
PPDEFFACTS: Displays the text of a given deffacts.
.PD 0
.P
.PD
> (ppdeffacts )
.PP
LIST-DEFFACTS: Displays the list of all deffacts in the specified module
(or the current module if none specified).
.PD 0
.P
.PD
> (list-deffacts [])
.PP
UNDEFFACTS: Deletes a deffacts.
.PD 0
.P
.PD
> (undeffacts )
.SS DEFRULE_COMMANDS
.PP
The following commands manipulate defrules.
.PP
PPDEFRULE: Displays the text of a given rule.
.PD 0
.P
.PD
> (ppdefrule )
.PP
LIST-DEFRULES: Displays the list of all defrules in the specified module
(or the current module if none specified).
.PD 0
.P
.PD
> (list-defrules [])
.PP
UNDEFRULE: Deletes a defrule.
.PD 0
.P
.PD
> (undefrule )
.PP
MATCHES: Displays the facts which match the patterns of a rule.
.PD 0
.P
.PD
> (matches )
.PP
SET-BREAK: Sets a breakpoint on a rule.
.PD 0
.P
.PD
> (set-break )
.PP
REMOVE-BREAK: Removes a breakpoint on a rule.
.PD 0
.P
.PD
> (remove-break [])
.PP
SHOW-BREAKS: Displays all rules having breakpoints.
.PD 0
.P
.PD
> (show-breaks [])
.PP
REFRESH: Places all current activations of a rule on the agenda.
.PD 0
.P
.PD
> (refresh )
.PP
SET-INCREMENTAL-RESET: Sets the incremental reset behavior.
.PD 0
.P
.PD
> (set-incremental-reset )
.PP
GET-INCREMENTAL-RESET: Returns the incremental reset behavior.
.PD 0
.P
.PD
> (get-incremental-reset)
.SS AGENDA_COMMANDS
.PP
The following commands manipulate the agenda.
.PP
AGENDA: Displays all activations on the agenda of the specified module.
.PD 0
.P
.PD
> (agenda [])
.PP
RUN: Starts execution of rules.
Rules fire until agenda is empty or the number of rule firings limit
specified by the first argument is reached (infinity if unspecified).
.PD 0
.P
.PD
> (run [])
.PP
FOCUS: Pushes one or more modules onto the focus stack.
.PD 0
.P
.PD
> (focus +)
.PP
HALT: Stops rule execution.
.PD 0
.P
.PD
> (halt)
.PP
SET-STRATEGY: Sets the current conflict resolution strategy.
.PD 0
.P
.PD
> (set-strategy ) > ::= depth | breadth | simplicity | complexity | lex
| mea | random
.PP
GET-STRATEGY: Returns the current conflict resolution strategy.
.PD 0
.P
.PD
> (get-strategy)
.PP
LIST-FOCUS-STACK: Lists all module names on the focus stack.
.PD 0
.P
.PD
> (list-focus-stack)
.PP
CLEAR-FOCUS-STACK: Removes all modules from the focus stack.
.PD 0
.P
.PD
> (clear-focus-stack)
.PP
SET-SALIENCE-EVALUATION: Sets the salience evaluation behavior.
.PD 0
.P
.PD
> (set-salience-evaluation ) > ::= when-defined | when-activated |
every-cycle
.PP
GET-SALIENCE-EVALUATION: Returns the salience evaluation behavior.
.PD 0
.P
.PD
> (get-salience-evaluation)
.PP
REFRESH-AGENDA: Forces reevaluation of salience of rules on the agenda
of the specified module.
.PD 0
.P
.PD
> (refresh-agenda [])
.SS DEFGLOBAL_COMMANDS
.PP
The following commands manipulate defglobals.
.PP
PPDEFGLOBAL: Displays the text required to define a given global
variable.
.PD 0
.P
.PD
> (ppdefglobal )
.PP
LIST-DEFGLOBALS: Displays the list of all defglobals in the specified
module (or the current module if none specified).
.PD 0
.P
.PD
> (list-defglobals [])
.PP
UNDEFGLOBAL: Deletes a global variable.
.PD 0
.P
.PD
> (undefglobal )
.PP
SHOWS-DEFGLOBALS: Displays the name and current value of all defglobals
in the specified module (or the current module if none specified).
.PD 0
.P
.PD
> (show-defglobals [])
.PP
SET-RESET-GLOBALS: Sets the reset global variables behavior.
.PD 0
.P
.PD
> (set-reset-globals )
.PP
GET-RESET-GLOBALS: Returns the reset global variables behavior.
.PD 0
.P
.PD
> (get-reset-globals)
.SS DEFFUNCTION_COMMANDS
.PP
The following commands manipulate deffunctions.
.PP
PPDEFFUNCTION: Displays the text of a given deffunction.
.PD 0
.P
.PD
> (ppdeffunction )
.PP
LIST-DEFFUNCTIONS: Displays the list of all deffunctions in the
specified module (or the current module if none specified).
.PD 0
.P
.PD
> (list-deffunctions [])
.PP
UNDEFFUNCTION: Deletes a deffunction.
.PD 0
.P
.PD
> (undeffunction )
.SS GENERIC_FUNCTION_COMMANDS
.PP
The following commands manipulate generic functions.
.PP
PPDEFGENERIC: Displays the text of a given generic function header.
.PD 0
.P
.PD
> (ppdefgeneric )
.PP
PPDEFMETHOD: Displays the text of a given method.
.PD 0
.P
.PD
> (ppdefmethod )
.PP
LIST-DEFGENERICS: Displays the names of all generic functions in the
specified module (or the current module if none specified).
.PD 0
.P
.PD
> (list-defgenerics [])
.PP
LIST-DEFMETHODS: Displays a list of generic function methods.
.PD 0
.P
.PD
> (list-defmethods [])
.PP
UNDEFGENERIC: Deletes a generic function.
.PD 0
.P
.PD
> (undefgeneric )
.PP
UNDEFMETHOD: Deletes a generic function method.
.PD 0
.P
.PD
> (undefmethod )
.PP
PREVIEW-GENERIC: Lists all applicable methods for a particular generic
function call in order of decreasing precedence.
.PD 0
.P
.PD
> (preview-generic *)
.SS COOL_COMMANDS
.PP
The commands manipulating the CLIPS Object-Oriented Language (COOL) are
divided into four categories.
.PP
Subtopics:
.PD 0
.P
.PD
\ \ \ \ CLASS_COMMANDS MESSAGE-HANDLER_COMMANDS
.PD 0
.P
.PD
\ \ \ \ DEFINSTANCES_COMMANDS INSTANCES_COMMANDS
.SS CLASS_COMMANDS
.PP
The following commands manipulate defclasses.
.PP
PPDEFCLASS: Displays the text of a given defclass.
.PD 0
.P
.PD
> (ppdefclass )
.PP
LIST-DEFCLASSES: Displays the list of all defclasses in the specified
module (or the current module if none specified).
.PD 0
.P
.PD
> (list-defclasses [])
.PP
UNDEFCLASS: Deletes a defclass, all its subclasses, and all associated
instances.
.PD 0
.P
.PD
> (undefclass )
.PP
DESCRIBE-CLASS: Provides a verbose description of a class.
.PD 0
.P
.PD
> (describe-class )
.PP
BROWSE-CLASSES: Provides a rudimentary display of the inheritance
relationships between a class and all its subclasses.
.PD 0
.P
.PD
> (browse-classes [])
.SS MESSAGE-HANDLER_COMMANDS
.RS
.PP
The following commands manipulate defmessage-handlers.
Note that is defined as follows: ::= around | before | primary | after
.RE
.PP
PPDEFMESSAGE-HANDLER: Displays the text of a given defmessage-handler.
.PD 0
.P
.PD
> (ppdefmessage-handler [])
.PP
LIST-DEFMESSAGE-HANDLERS: Displays a list of all (or some) defmessage-
handlers.
.PD 0
.P
.PD
> (list-defmessage-handlers [ [ []]])
.PP
UNDEFMESSAGE-HANDLER: Deletes a defmessage-handler.
.PD 0
.P
.PD
> (undefmessage-handler [])
.PP
PREVIEW-SEND: Displays a list of all the applicable message-handlers for
a message sent to an instance of a particular class.
.PD 0
.P
.PD
> (preview-send )
.SS DEFINSTANCES_COMMANDS
.PP
The following commands manipulate definstances.
.PP
PPDEFINSTANCES: Displays the text of a given definstances.
.PD 0
.P
.PD
> (ppdefinstances )
.PP
LIST-DEFINSTANCES: Displays the list of all definstances in the
specified module (or the current module if none specified).
.PD 0
.P
.PD
> (list-definstances [])
.PP
UNDEFINSTANCES: Deletes a definstances.
.PD 0
.P
.PD
> (undefinstances )
.SS INSTANCES_COMMANDS
.PP
The following commands manipulate instances of user-defined classes.
.PP
INSTANCES: Displays a list of instances.
.PD 0
.P
.PD
> (instances [ [ [inherit]]])
.PP
PPINSTANCE: Prints the slots of the active instance when called from
within the body of a message-handler.
.PD 0
.P
.PD
> (ppinstance)
.PP
SAVE-INSTANCES: Saves all instances to the specified file.
.PD 0
.P
.PD
> (save-instances )
.PP
LOAD-INSTANCES: Loads instances from the specified file.
.PD 0
.P
.PD
> (load-instances )
.PP
RESTORE-INSTANCES: Loads instances from the specified file.
.PD 0
.P
.PD
> (restore-instances )
.SS DEFMODULE_COMMANDS
.PP
The following commands manipulate defmodules.
.PP
PPDEFMODULE: Displays the text of a given defmodule.
.PD 0
.P
.PD
> (ppdefmodule )
.PP
LIST-DEFMODULES: Displays the list of all defmodules.
.PD 0
.P
.PD
> (list-defmodules)
.PP
SET-CURRENT-MODULE: Sets the current module.
.PD 0
.P
.PD
> (set-current-module )
.PP
GET-CURRENT-MODULE: Returns the current module.
.PD 0
.P
.PD
> (get-current-module)
.SS MEMORY_COMMANDS
.PP
The following commands display CLIPS memory status information.
.PP
MEM-USED: Returns the number of bytes of memory CLIPS is using.
.PD 0
.P
.PD
> (mem-used)
.PP
MEM-REQUESTS: Returns the number of times CLIPS has requested memory
from the operating system.
.PD 0
.P
.PD
> (mem-requests)
.PP
RELEASE-MEM: Releases all free memory held internally by CLIPS to the
operating system.
Returns the amount of memory freed.
.PD 0
.P
.PD
> (release-mem)
.PP
CONSERVE-MEM: Turns on or off the storage of information used for the
save and pretty-print commands.
.PD 0
.P
.PD
> (conserve-mem ) > ::= on | off
.SS TEXT_PROCESSING_COMMANDS
.PP
The following commands can be used by users to maintain their own
information system similar to the help facility.
.PP
FETCH: Loads the named file into the internal lookup table.
.PD 0
.P
.PD
> (fetch )
.PP
PRINT-REGION: Looks up the specified entry in a particular file which
has been previously loaded into the lookup table and prints the contents
of that entry to the specified logical name.
.PD 0
.P
.PD
> (print-region *)
.PP
GET-REGION: Looks up a specified entry in a particular file which has
been loaded previously into the lookup table and returns the contents of
that entry as a string.
.PD 0
.P
.PD
> (get region *)
.PP
TOSS: Unloads the named file from the internal lookup table.
.PD 0
.P
.PD
> (toss )
.SS PROFILING_COMMANDS
.PP
The following commands provide the ability to profile CLIPS programs for
performance.
.PP
SET-PROFILE-PERCENT-THRESHOLD: Sets the minimum percentage of time that
must be spent executing a construct or user function for it to be
displayed by the profile-info command.
.PD 0
.P
.PD
> (set-profile-percent-threshold <number in the range 0 to 100>)
.PP
GET-PROFILE-PERCENT-THRESHOLD: Returns the current value of the profile
percent threshold.
.PD 0
.P
.PD
> (get-profile-percent-threshold)
.PP
PROFILE-RESET: Resets all profiling information currently collected for
constructs and user functions.
.PD 0
.P
.PD
> (profile-reset)
.PP
PROFILE-INFO: Displays profiling information currently collected for
constructs or user functions.
.PD 0
.P
.PD
> (profile-info)
.PP
PROFILE: Enables/disables profiling of constructs and user functions.
.PD 0
.P
.PD
> (profile constructs | user-functions | off)
.SH INTEGRATED_EDITOR
.PP
CLIPS includes a fully integrated version of the full screen MicroEMACS
editor.
You may call the editor from CLIPS, compile full buffers or just
sections of the editor (incremental compile), temporarily exit the
editor back to CLIPS, or permanently exit the editor.
Since the editor is full screen, portions of it are highly machine
dependent.
As it is currently set up, the editor will run on VAX VMS machines using
VT100- or VT240-compatible terminals, UNIX systems which support
TERMCAP, the IBM PC, and most IBM compatibles.
.PP
Subtopics:
.PD 0
.P
.PD
\ \ \ USING_THE_EDITOR EXTENDED_COMMANDS
.PD 0
.P
.PD
\ \ \ CONTROL_COMMANDS META_COMMANDS
.SS USING THE EDITOR
.PP
The editor may be called from CLIPS with the following command:
.RS
.PP
(edit [\[lq]\[rq]])
.RE
.PP
The file name is optional.
If one is given, that file would be loaded.
If no file name is given, the editor is entered without loading a file.
Once in the file, all of the EMACS commands listed below are applicable.
To exit the editor and clear all buffers, use or .
To temporarily exit the editor and retain the information in the
buffers, use Q.
To compile a rules section, mark a region and type .
To compile the entire buffer, use .
The editor can use extensive amounts of memory and a flag is available
in clips.h to remove all of the editor code.
When using the editor on multiuser machines like the VAX or many UNIX
environments, be careful with the control S and control Q commands; they
could conflict with terminal XON/XOFF communications.
All of the control S commands have a work around built into the editor.
The save file command, normally , is also
Z.
The forward search command, normally , is also
.PP
J.
The control Q command is rarely needed in a CLIPS file and, therefore,
has no substitute.
.PP
The following two special characters should be noted when using the
editor.
.PP
Delete previous character.
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (also on some terminals)
.PD 0
.P
.PD
Meta command prefix.
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (also <ctrl-[> on some
terminals)
.SS CONTROL_COMMANDS
.PP
These commands are entered by pressing the control key along with the
designated character.
.PP
<ctrl-\[at]> Set mark at current position.
.PD 0
.P
.PD
Move cursor to beginning of line.
.PD 0
.P
.PD
Move cursor BACK one character.
.PD 0
.P
.PD
Start a new interactive command shell.
Be careful!
.PD 0
.P
.PD
DELETE character under cursor.
.PD 0
.P
.PD
Move cursor to END of line.
.PD 0
.P
.PD
Move cursor FORWARD one character.
.PD 0
.P
.PD
Abort any command.
.PD 0
.P
.PD
(backspace) delete previous character.
.PD 0
.P
.PD
Insert a TAB.
.PD 0
.P
.PD
Insert a CR-LF and indent next line.
.PD 0
.P
.PD
KILL (delete) to end of line.
.PD 0
.P
.PD
Redisplay screen.
.PD 0
.P
.PD
Insert a CR-LF.
.PD 0
.P
.PD
Move cursor to NEXT line.
.PD 0
.P
.PD
OPEN a new line.
.PD 0
.P
.PD
Move to PREVIOUS line.
.PD 0
.P
.PD
QUOTE the next character (insert the next character typed).
.PD 0
.P
.PD
Reverse SEARCH.
.PD 0
.P
.PD
Forward SEARCH (also ).
.PD 0
.P
.PD
TRANSPOSE characters.
.PD 0
.P
.PD
Enter repeat count for next command.
.PD 0
.P
.PD
VIEW the next screen (scroll up one screen).
.PD 0
.P
.PD
KILL region (all text between cursor and last mark set).
.PD 0
.P
.PD
Extended command prefix - see below.
.PD 0
.P
.PD
YANK (undelete) last text killed.
.PD 0
.P
.PD
Quick save of file in current buffer (only) and exit.
.SS EXTENDED_COMMANDS
.PP
These commands are entered by first pressing the control key along with
the `x' character and then pressing the designated character.
.PP
( Begin keyboard Macro.
.PD 0
.P
.PD
) End keyboard Macro.
.PD 0
.P
.PD
! Execute a single external command.
.PD 0
.P
.PD
= Show current cursor column and line number.
.PD 0
.P
.PD
: Go to a specific line number.
.PD 0
.P
.PD
1 Display current window only.
.PD 0
.P
.PD
2 Split the current window.
.PD 0
.P
.PD
B Switch to a different BUFFER.
.PD 0
.P
.PD
E EXECUTE keyboard Macro.
.PD 0
.P
.PD
F Set FILL column.
.PD 0
.P
.PD
K KILL a buffer (other than current buffer).
.PD 0
.P
.PD
M MATCH parenthesis (or {} or []).
.PD 0
.P
.PD
N Move to NEXT window.
.PD 0
.P
.PD
P Move to PREVIOUS window.
.PD 0
.P
.PD
R Global search and REPLACE (backwards).
.PD 0
.P
.PD
S Global SEARCH and replace (forwards).
.PD 0
.P
.PD
Z Enlarge current window by repeat count lines.
.PD 0
.P
.PD
.PD 0
.P
.PD
Show active BUFFERS.
.PD 0
.P
.PD
Exit without saving buffers.
.PD 0
.P
.PD
FIND file.
Load if not already in buffer.
.PD 0
.P
.PD
Scroll current window up by repeat count lines.
.PD 0
.P
.PD
Scroll current window down by repeat count lines.
.PD 0
.P
.PD
RENAME file.
Change file name for buffer.
.PD 0
.P
.PD
SAVE (write) current buffer into its file.
.PD 0
.P
.PD
VISIT a file.
Read file and display in current window.
.PD 0
.P
.PD
WRITE buffer to file.
Option to change name of file.
.PD 0
.P
.PD
Reduce current window by repeat count lines.
.SS META_COMMANDS
.PP
These commands are entered by first pressing the meta key (Activated by
or <ctrl-[>) and then pressing the designated character.
|
! Move current line to repeat count lines from top of | window.
.PD 0
.P
.PD
|
.RS
.IP
.nf
\f[C]
           Move cursor to end of buffer.
\f[R]
.fi
|
< Move cursor to beginning of buffer.
.PD 0
.P
.PD
|
\&.
Set mark.
.PD 0
.P
.PD
|
B Move cursor BACK one word.
.PD 0
.P
.PD
|
C CAPITALIZE first letter of word.
.PD 0
.P
.PD
|
D DELETE next word.
.PD 0
.P
.PD
|
F Move cursor FORWARD one word.
.PD 0
.P
.PD
|
J SEARCH forward (same as ).
.PD 0
.P
.PD
|
L LOWERCASE (lowercase) next word.
.PD 0
.P
.PD
|
R Query search and REPLACE (backwards).
.PD 0
.P
.PD
|
S Query SEARCH and replace (forwards).
.PD 0
.P
.PD
|
U UPPERCASE (uppercase) next word.
.PD 0
.P
.PD
|
V VIEW the previous screen (scroll down one screen).
.PD 0
.P
.PD
|
W COPY region into kill buffer.
.PD 0
.P
.PD
|
Z SAVE current buffer into file (same as | ).
.PD 0
.P
.PD
|
.PP
DELETE previous word.
.RE
.SH HISTORY
.SS V6.21
.IP \[bu] 2
Bug Fixes - The following bugs were fixed by the 6.21 release:
.RS 2
.IP \[bu] 2
The C GetDefglobalValue macro did not have the correct number of
arguments.
.IP \[bu] 2
The C RtnArgCount macro did not have the correct number of arguments.
.IP \[bu] 2
Erroneous error generated for object pattern under some circumstances.
.IP \[bu] 2
The C Save macro did not have the correct number of arguments.
.IP \[bu] 2
The C Eval and Build functions did not have the correct number of
arguments.
.IP \[bu] 2
The progn$ index variable did not always return the correct value.
.IP \[bu] 2
The member$ function did not always return the correct value.
.IP \[bu] 2
C++ style comments in the code caused errors when using strict ANSI C
compilation.
.IP \[bu] 2
The C LoadFactsFromString function did not have the correct number of
arguments.
.IP \[bu] 2
Prior bug fix to the PutFactSlot C function prevented memory associated
with the fact to be garbage collected after the fact had been retracted.
The original bug is now fixed through a new API which allows embedded
programs to temporarily disable garbage collection.
See section 1.4 of The Advanced Programming Guide for more details.
.RE
.SS V6.22
.IP \[bu] 2
Bug Fixes - The following bugs were fixed by the 6.22 release:
.RS 2
.IP \[bu] 2
Numerous fixes for functions and macros that did not accept the correct
number of arguments as specified in the Advanced Programming Guide.
The following functions and macros were corrected: Agenda, BatchStar,
EnvGetActivationSalience, EnvBatchStar, EnvFactDeftemplate,
EnvFactExistp, EnvFactList, EnvFactSlotNames,
EnvGetNextInstanceInClassAndSubclasses, EnvLoadInstancesFromString,
EnvRestoreInstancesFromString, EnvSetOutOfMemoryFunction,
FactDeftemplate, FactExistp, FactList, FactSlotNames,
GetNextInstanceInClassAndSubclasses, LoadInstancesFromString,
RestoreInstancesFromString, and SetOutOfMemoryFunction.
.RE
.SS V6.23
.IP \[bu] 2
Fact-Set Query Functions - Six new functions similar to the instance set
query functions have been added for determining and performing actions
on sets of facts that satisfy user-defined queries (see section 12.9.12
of the Basic Programming Guide): any-factp, find-fact, find-all-facts,
do-for-fact, do-for-all-facts, and delayed-do-for-all-facts.
The GetNextFactInTemplate function (see section 4.4.17 of the Advanced
Programming Guide) allows iteration from C over the facts belonging to a
specific deftemplate.
.IP \[bu] 2
Bug Fixes - The following bugs were fixed by the 6.23 release:
.RS 2
.IP \[bu] 2
Passing the wrong number of arguments to a deffunction through the
funcall function could cause unpredictable behavior including memory
corruption.
.IP \[bu] 2
A large file name (at least 60 characters) passed into the fetch command
causes a buffer overrun.
.IP \[bu] 2
A large file name (at least 60 characters) passed into the
constructs-to-c command causes a buffer overrun.
.IP \[bu] 2
A large defclass or defgeneric name (at least 500 characters) causes a
buffer overrun when the profile-info command is called.
.IP \[bu] 2
A large module or construct name (at least 500 characters) causes a
buffer overrun when the get--list command is called.
.IP \[bu] 2
The FalseSymbol and TrueSymbol constants were not defined as described
in the Advanced Programming Guide.
These constants have have now been defined as macros so that their
corresponding environment companion functions (EnvFalseSymbol and
EnvTrueSymbol) could be defined.
See the Advanced Programming Guide for more details.
.IP \[bu] 2
The slot-writablep function returns TRUE for slots having
initialize-only access.
.IP \[bu] 2
Files created by the constructs-to-c function for use in a run-time
program generate compilation errors.
.RE
.IP \[bu] 2
Command and Function Changes - The following commands and functions have
been enhanced:
.RS 2
.IP \[bu] 2
funcall (see section 12.7.10 of the Basic Programming Guide).
.PD 0
.P
.PD
Multifield arguments are no longer expanded into multiple arguments
before being passed to the target function of the funcall.
The expand$ function can be placed around an argument to revert to the
old behavior.
.RE
.IP \[bu] 2
Compiler Support - The following compilers are now supported.
See the Interfaces Guide for more details.
.RS 2
.IP \[bu] 2
Metrowerks CodeWarrior 9.4 for Mac OS X and Windows.
.IP \[bu] 2
Xcode 1.2 for Mac OS X.
.RE
.SS V6.24
.IP \[bu] 2
Allowed Classes Constraint Attribute - The allowed-classes constraint
attribute allows a slot containing an instance value to be restricted to
the specified list of classes (see section 11.2 of the Basic Programming
Guide).
.IP \[bu] 2
New Functions and Commands - Several new functions and commands have
been added.
They are:
.RS 2
.IP \[bu] 2
deftemplate-slot-allowed-values (see section 12.8.2 of the BPG)
.IP \[bu] 2
deftemplate-slot-cardinality (see section 12.8.3 of the BPG)
.IP \[bu] 2
deftemplate-slot-defaultp (see section 12.8.4 of the BPG)
.IP \[bu] 2
deftemplate-slot-default-value (see section 12.8.5 of the BPG)
.IP \[bu] 2
deftemplate-slot-existp (see section 12.8.6 of the BPG)
.IP \[bu] 2
deftemplate-slot-multip (see section 12.8.7 of the BPG)
.IP \[bu] 2
deftemplate-slot-names (see section 12.8.8 of the BPG)
.IP \[bu] 2
deftemplate-slot-range (see section 12.8.9 of the BPG)
.IP \[bu] 2
deftemplate-slot-singlep (see section 12.8.10 of the BPG)
.IP \[bu] 2
deftemplate-slot-type (see section 12.8.11 of the BPG)
.IP \[bu] 2
get-char (see section 12.4.2.9 of the BPG)
.IP \[bu] 2
get-region (see section 13.15.2.3 of the BPG)
.IP \[bu] 2
ppfact (see section 13.4.6 of the BPG)
.IP \[bu] 2
read-number (see section 12.4.2.10 of the BPG)
.IP \[bu] 2
set-locale (see section 12.4.2.11 of the BPG)
.IP \[bu] 2
slot-allowed-classes (see section 12.16.1.27 of the BPG)
.RE
.IP \[bu] 2
Command and Function Changes The following commands and functions have
been enhanced:
.RS 2
.IP \[bu] 2
format (see section 12.4.2.6 of the Basic Programming Guide).
The formatting of printed numbers can be changed to use a native locale
with the set-locale function.
The documentation has been updated to include the effect of the
precision argument on the d, g, o, and x format flags.
.RE
.IP \[bu] 2
Behavior Changes - The following changes have been made to behavior:
.RS 2
.IP \[bu] 2
The message displayed when a construct is redefined and compilations are
being watched is now more prominent.
.RE
.IP \[bu] 2
Bug Fixes - The following bugs were fixed by the 6.24 release:
.RS 2
.IP \[bu] 2
The DescribeClass macros were incorrectly defined.
.IP \[bu] 2
The sort function leaks memory when called with a multifield value of
length zero.
.IP \[bu] 2
Link error occurred for the SlotExistError function when OBJECT_SYSTEM
is set to 0 in setup.h.
.IP \[bu] 2
An error when calling the Eval function causes a subsequent call to
DeallocateEnvironmentData to fail.
.IP \[bu] 2
Loading a binary instance file from a run-time program caused a bus
error.
.IP \[bu] 2
Incorrect activations could occur with the exists CE.
.IP \[bu] 2
Compilation errors occurred when compiling CLIPS source as C++ files.
.IP \[bu] 2
The AssignFactSlotDefaults function did not correctly handle defaults
for multifield slots.
.IP \[bu] 2
The slot-default-value function crashed when no default existed for a
slot (the ?NONE value was specified).
.IP \[bu] 2
CLIPS crashed on AMD64 processor in the function used to generate hash
values for integers.
.IP \[bu] 2
A syntax error was not generated for the last deffunction or defmethod
in a file if it was missing the final closing right parenthesis.
.RE
.IP \[bu] 2
Compiler Support - The following compilers are now supported.
See the Interfaces Guide for more details.
.RS 2
.IP \[bu] 2
Metrowerks CodeWarrior 9.6 for Mac OS X.
.IP \[bu] 2
Xcode 2.3 for Mac OS X.
.IP \[bu] 2
Microsoft Visual C++ .NET 2003 for Windows.
.RE
.SH SUPPORT INFORMATION
.PP
CLIPS executables, documentation, and source code are available for
download from http://www.ghg.net/clips/download/.
.PP
Questions regarding CLIPS can be sent via electronic mail to
clipsYYYY\[at]ghg.net where YYYY is the current year (for example,
2004).
.PD 0
.P
.PD
Include the words `CLIPS USER' in the subject line.
.PP
An electronic conferencing facility, sponsored by Distributed Computing
Systems (http://www.discomsys.com), is also available to CLIPS users.
.PD 0
.P
.PD
Subscribers to this facility may send questions, observations, answers,
editorials, etc., in the form of electronic mail to the conference.
All subscribers will have a copy of these messages reflected back to
them at their respective electronic mail addresses.
To subscribe, send a single line message to
clips-request\[at]discomsys.com containing the word \[lq]subscribe\[rq].
The subject field is ignored but the address found in the Reply:, Reply
to:, or From: field will be entered in the distribution list.
Upon subscription you will receive a mail message instructing you how to
participate in the conference from that point forward.
Save this mail message.
You may need the instructions later if you wish to unsubscribe from the
list server.
.PP
To send your own messages to members of the conference you need simply
address your mail to clips\[at]discomsys.com.
Your message will be reflected to all other members of the conference.
.PP
If you wish to remove yourself from the conference and discontinue
receiving mail simply send a message to clips-request\[at]discomsys.com
with \[lq]unsubscribe\[rq] as the message text.
If you want to unsubscribe using another email account than the one you
subscribed with, then append the original subscribing email account to
the text of the message.
For example: \[lq]unsubscribe john.doe\[at]account.net\[rq].
Do not send unsubscribe messages to clips\[at]discomsys.com! This sends
a mail message to every member of the list.
If you need to get in contact with the list administrator (for trouble
unsubscribing or other questions about the list), send email to
clips-owner\[at]discomsys.com.
.PP
A CLIPS World Wide Web page can be accessed using the URL
http://www.ghg.net/clips/CLIPS.html.
.PP
Usenet users can also find information and post questions about CLIPS to
the comp.ai.shells news group.
.PP
The CLIPS Developers\[cq] Forum, a thread-based message board, is
available at http://www.cpbinc.com/clips.
This board exists to provide a site for discussion of research,
development, and implementation of the CLIPS expert systems and related
technologies.
The hosting services for this web page are provided by CPB,
Inc.\ Questions pertaining to this forum can be sent to
clips\[at]cpbinc.com.
